import React, { useRef, useImperativeHandle, forwardRef, useCallback, useEffect } from 'react'

export interface RichTextEditorHandle {
  insertDictation: (text: string) => void
  getValue: () => string
  getPlainText: () => string
  setValue: (html: string) => void
  focus: () => void
  getElement: () => HTMLDivElement | null
  saveCursor: () => void
}

interface RichTextEditorProps {
  value: string
  onChange: (value: string) => void
  placeholder?: string
  style?: React.CSSProperties
  className?: string
}

const RichTextEditor = forwardRef<RichTextEditorHandle, RichTextEditorProps>(
  ({ value, onChange, placeholder, style, className }, ref) => {
    const editorRef = useRef<HTMLDivElement>(null)
    const isInternalChange = useRef(false)
    const lastValue = useRef<string>('')
    const savedRange = useRef<Range | null>(null)
    const lastInteractionTime = useRef<number>(0)

    // Format text with basic HTML
    const formatText = useCallback((text: string) => {
      if (!text) return ''
      
      // Keep it simple - just replace newlines with <br>
      return text.replace(/\n/g, '<br>')
    }, [])

    // Save cursor position
    const saveCursorPosition = useCallback(() => {
      if (!editorRef.current) return
      
      const selection = window.getSelection()
      if (selection && selection.rangeCount > 0) {
        const range = selection.getRangeAt(0)
        
        // Check if range is in our editor - be more permissive
        let isInEditor = false
        let node = range.commonAncestorContainer
        
        // Walk up the DOM tree to check if we're inside the editor
        while (node) {
          if (node === editorRef.current) {
            isInEditor = true
            break
          }
          node = node.parentNode
        }
        
        if (isInEditor) {
          savedRange.current = range.cloneRange()
          lastInteractionTime.current = Date.now()
          console.log('💾 Saved cursor position:', {
            startOffset: range.startOffset,
            endOffset: range.endOffset,
            collapsed: range.collapsed,
            container: range.commonAncestorContainer.nodeName,
            containerText: range.commonAncestorContainer.textContent?.substring(0, 50)
          })
        } else {
          // If no valid selection, create one at the end of editor
          const newRange = document.createRange()
          newRange.selectNodeContents(editorRef.current)
          newRange.collapse(false)
          savedRange.current = newRange
          lastInteractionTime.current = Date.now()
          console.log('💾 Created cursor at end of editor')
        }
      } else {
        // No selection at all - create one at the end
        const newRange = document.createRange()
        newRange.selectNodeContents(editorRef.current)
        newRange.collapse(false)
        savedRange.current = newRange
        lastInteractionTime.current = Date.now()
        console.log('💾 Created default cursor at end')
      }
    }, [])
    
    // Handle input changes
    const handleInput = useCallback(() => {
      if (editorRef.current && !isInternalChange.current) {
        const html = editorRef.current.innerHTML
        lastValue.current = html
        onChange(html)
      }
      isInternalChange.current = false
      // Save cursor position after input
      saveCursorPosition()
    }, [onChange, saveCursorPosition])

    // Handle paste to maintain formatting
    const handlePaste = useCallback((e: React.ClipboardEvent) => {
      e.preventDefault()
      const text = e.clipboardData.getData('text/plain')
      document.execCommand('insertText', false, text)
    }, [])

    // Initialize editor with initial value
    useEffect(() => {
      if (editorRef.current) {
        const initialValue = value || ''
        editorRef.current.innerHTML = initialValue
        lastValue.current = initialValue
      }
    }, []) // Only run once on mount
    
    // Update editor content when value prop changes
    useEffect(() => {
      if (!editorRef.current) return
      
      // Always update if the content is different
      if (value !== editorRef.current.innerHTML) {
        console.log('📝 Syncing value to editor:', { 
          value, 
          currentHTML: editorRef.current.innerHTML,
          valueLength: value?.length 
        })
        editorRef.current.innerHTML = value || ''
        lastValue.current = value || ''
      }
    }, [value])
    
    // Periodically save cursor position when editor has focus
    useEffect(() => {
      const interval = setInterval(() => {
        if (document.activeElement === editorRef.current) {
          saveCursorPosition()
        }
      }, 500) // Save every 500ms when focused
      
      return () => clearInterval(interval)
    }, [saveCursorPosition])
    
    // Handle focus to place cursor at end if no saved position
    const handleFocus = useCallback(() => {
      console.log('🎯 Editor focused')
      // If we don't have a saved range, place cursor at end
      if (!savedRange.current && editorRef.current) {
        const selection = window.getSelection()
        const range = document.createRange()
        range.selectNodeContents(editorRef.current)
        range.collapse(false) // Collapse to end
        selection?.removeAllRanges()
        selection?.addRange(range)
      }
      saveCursorPosition()
    }, [saveCursorPosition])
    
    // Handle click to save cursor position
    const handleClick = useCallback((e: React.MouseEvent) => {
      console.log('🎯 Editor clicked')
      // Small delay to let the cursor position settle
      setTimeout(() => {
        saveCursorPosition()
      }, 10)
    }, [saveCursorPosition])

    // Expose methods via ref
    useImperativeHandle(ref, () => ({
      insertDictation: (text: string) => {
        console.log('🎤 RichTextEditor.insertDictation called with:', text)
        if (!editorRef.current) {
          console.error('🎤 RichTextEditor: editorRef.current is null!')
          return
        }
        
        // Simple approach - just append with proper spacing
        const existingText = editorRef.current.textContent || ''
        let newText = text.trim()
        
        if (!newText) return
        
        // Add spacing
        if (existingText.length > 0) {
          // Check last character of existing text
          const lastChar = existingText[existingText.length - 1]
          // Add space unless existing text ends with space or newline
          if (lastChar !== ' ' && lastChar !== '\n') {
            newText = ' ' + newText
          }
        }
        
        // Capitalize if at beginning or after sentence end
        if (existingText.length === 0 || /[.!?]\s*$/.test(existingText)) {
          newText = newText.charAt(0).toUpperCase() + newText.slice(1)
        }
        
        // Create text node and append
        const textNode = document.createTextNode(newText)
        editorRef.current.appendChild(textNode)
        
        // Update internal state
        const newHtml = editorRef.current.innerHTML
        lastValue.current = newHtml
        
        // Notify parent
        onChange(newHtml)
        
        console.log('🎤 Dictation inserted successfully')
      },
      getValue: () => {
        const value = editorRef.current?.innerHTML || lastValue.current || '';
        console.log('🔍 getValue called, returning:', { value, length: value.length });
        return value;
      },
      getPlainText: () => {
        const text = editorRef.current?.innerText || '';
        console.log('🔍 getPlainText called, returning:', { text, length: text.length });
        return text; (e.g., "3 o'clock" → "3:00")
          processed = processed.replace(/(\d{1,2})\s*o['']?\s*clock/gi, (match, hour) => {
            const h = parseInt(hour)
            if (h >= 1 && h <= 12) {
              return `${h}:00`
            }
            return match
          })
          
          // Handle "half past" time format
          processed = processed.replace(/half\s+past\s+(\d{1,2})/gi, (match, hour) => {
            const h = parseInt(hour)
            if (h >= 1 && h <= 12) {
              return `${h}:30`
            }
            return match
          })
          
          // Handle "quarter past" and "quarter to"
          processed = processed.replace(/quarter\s+past\s+(\d{1,2})/gi, (match, hour) => {
            const h = parseInt(hour)
            if (h >= 1 && h <= 12) {
              return `${h}:15`
            }
            return match
          })
          
          processed = processed.replace(/quarter\s+to\s+(\d{1,2})/gi, (match, hour) => {
            const h = parseInt(hour)
            if (h >= 1 && h <= 12) {
              const actualHour = h === 1 ? 12 : h - 1
              return `${actualHour}:45`
            }
            return match
          })
          
          // Word to symbol replacements (case-insensitive)
          const replacements: { [key: string]: string } = {
            'slash': '/',
            'forward slash': '/',
            'back slash': '\\',
            'backslash': '\\',
            'semi colon': ';',
            'semicolon': ';',
            'semi-colon': ';',
            'colon': ':',
            'comma': ',',
            'period': '.',
            'full stop': '.',
            'exclamation': '!',
            'exclamation point': '!',
            'exclamation mark': '!',
            'question mark': '?',
            'open paren': '(',
            'open parenthesis': '(',
            'close paren': ')',
            'close parenthesis': ')',
            'open bracket': '[',
            'close bracket': ']',
            'open brace': '{',
            'close brace': '}',
            'ampersand': '&',
            'and sign': '&',
            'at sign': '@',
            'at symbol': '@',
            'hash': '#',
            'hashtag': '#',
            'pound sign': '#',
            'dollar sign': '$',
            'percent': '%',
            'percent sign': '%',
            'caret': '^',
            'asterisk': '*',
            'star': '*',
            'plus': '+',
            'plus sign': '+',
            'minus': '-',
            'minus sign': '-',
            'dash': '-',
            'hyphen': '-',
            'underscore': '_',
            'equals': '=',
            'equal sign': '=',
            'double quote': '"',
            'single quote': "'",
            'apostrophe': "'",
            'less than': '<',
            'greater than': '>',
            'pipe': '|',
            'vertical bar': '|',
            'tilde': '~',
            'bullet': '•',
            'bullet point': '•',
            'degree': '°',
            'degrees': '°',
          }
          
          // Replace complete words/phrases
          for (const [phrase, symbol] of Object.entries(replacements)) {
            const regex = new RegExp(`\\b${phrase}\\b`, 'gi')
            processed = processed.replace(regex, symbol)
          }
          
          return { text: processed, isCommand: false }
        }
        
        // Process the input text for voice commands
        const { text: processedInput, isCommand } = processVoiceCommands(text)
        
        // Get selection and try to place cursor
        const selection = window.getSelection()
        let range = selection && selection.rangeCount > 0 ? selection.getRangeAt(0) : null
        let hasValidRange = false
        
        // Check if we have a valid range in the editor
        if (range && editorRef.current) {
          // Walk up the DOM tree to check if range is in editor
          let node = range.commonAncestorContainer
          while (node) {
            if (node === editorRef.current) {
              hasValidRange = true
              break
            }
            node = node.parentNode
          }
        }
        
        // Process the dictated text
        let processedText = processedInput.trim()
        
        // Handle special commands (paragraph, newline)
        if (isCommand) {
          if (hasValidRange && range) {
            // Delete any selected content first
            if (!range.collapsed) {
              range.deleteContents()
            }
            
            // Insert line breaks
            if (processedInput === '\n\n') {
              // Insert paragraph break
              const br1 = document.createElement('br')
              const br2 = document.createElement('br')
              range.insertNode(br2)
              range.insertNode(br1)
              range.setStartAfter(br2)
              range.setEndAfter(br2)
            } else if (processedInput === '\n') {
              // Insert single line break
              const br = document.createElement('br')
              range.insertNode(br)
              range.setStartAfter(br)
              range.setEndAfter(br)
            }
            
            range.collapse(false)
            selection.removeAllRanges()
            selection.addRange(range)
          } else {
            // No range - append at end
            if (processedInput === '\n\n') {
              editorRef.current.appendChild(document.createElement('br'))
              editorRef.current.appendChild(document.createElement('br'))
            } else if (processedInput === '\n') {
              editorRef.current.appendChild(document.createElement('br'))
            }
          }
          
          // Update state and return early for commands
          const newHtml = editorRef.current.innerHTML
          lastValue.current = newHtml
          onChange(newHtml)
          return
        }
        
        if (hasValidRange && range) {
          console.log('🎤 Inserting at cursor/selection position')
          
          // Get text before and after cursor for context
          let textBefore = ''
          let textAfter = ''
          
          if (range.startContainer.nodeType === Node.TEXT_NODE) {
            textBefore = range.startContainer.textContent?.substring(0, range.startOffset) || ''
          }
          if (range.endContainer.nodeType === Node.TEXT_NODE) {
            textAfter = range.endContainer.textContent?.substring(range.endOffset) || ''
          }
          
          // If there's a selection, expand it to include complete words
          if (!range.collapsed) {
            // Expand selection to word boundaries
            if (range.startContainer.nodeType === Node.TEXT_NODE) {
              const text = range.startContainer.textContent || ''
              let start = range.startOffset
              while (start > 0 && !/\s/.test(text[start - 1])) {
                start--
              }
              range.setStart(range.startContainer, start)
            }
            if (range.endContainer.nodeType === Node.TEXT_NODE) {
              const text = range.endContainer.textContent || ''
              let end = range.endOffset
              while (end < text.length && !/\s/.test(text[end])) {
                end++
              }
              range.setEnd(range.endContainer, end)
            }
          }
          
          // Delete the selected content (or nothing if cursor only)
          range.deleteContents()
          
          // Check if processedText is punctuation
          const isPunctuation = /^[,.!?;:]$/.test(processedText)
          
          // Capitalize if needed
          if (!isPunctuation) {
            const trimmedBefore = textBefore.trimEnd()
            if (trimmedBefore.length === 0 || /[.!?]\s*$/.test(trimmedBefore)) {
              processedText = processedText.charAt(0).toUpperCase() + processedText.slice(1)
            }
          }
          
          // Add spacing
          if (!isPunctuation) {
            // Always add space before non-punctuation if there's text before without trailing space
            if (textBefore.length > 0 && !/\s$/.test(textBefore)) {
              processedText = ' ' + processedText
            }
            // Add space after if there's text after without leading space/punctuation
            if (textAfter.length > 0 && !/^[\s.,;:!?]/.test(textAfter)) {
              processedText = processedText + ' '
            }
          }
          
          // Insert the new text
          const textNode = document.createTextNode(processedText)
          range.insertNode(textNode)
          
          // Move cursor after inserted text
          range.setStartAfter(textNode)
          range.setEndAfter(textNode)
          range.collapse(false)
          selection.removeAllRanges()
          selection.addRange(range)
        } else {
          // No valid range in editor - try to place cursor at end and insert there
          console.log('🎤 No valid cursor position - will place at end')
          
          // Place cursor at the end of content
          const endRange = document.createRange()
          endRange.selectNodeContents(editorRef.current)
          endRange.collapse(false)
          
          const selection = window.getSelection()
          selection?.removeAllRanges()
          selection?.addRange(endRange)
          
          const existingText = editorRef.current.textContent || ''
          
          // Check if processedText is a single symbol/punctuation
          const isSymbol = /^[\/\\;:,.!?()[\]{}@#$%^&*+=|~`"'<>-]$/.test(processedText.trim())
          
          console.log('🎤 Appending text:', {
            existingTextEnd: existingText.slice(-20), // last 20 chars
            processedText: processedText,
            isSymbol,
            existingLength: existingText.length,
            needsSpace: existingText.length > 0 && !/\s$/.test(existingText) && !isSymbol
          })
          
          // Capitalize if at start or after sentence (but not for symbols)
          if (!isSymbol) {
            if (existingText.length === 0) {
              // First text - capitalize
              processedText = processedText.charAt(0).toUpperCase() + processedText.slice(1)
            } else if (/[.!?]\s*$/.test(existingText)) {
              // After sentence ending - capitalize
              processedText = processedText.charAt(0).toUpperCase() + processedText.slice(1)
            }
          }
          
          // Add space before new text if needed
          if (existingText.length > 0 && !isSymbol) {
            // Add space if existing text doesn't end with space
            if (!/\s$/.test(existingText)) {
              processedText = ' ' + processedText
              console.log('🎤 Added space before text')
            }
          }
          
          // Insert at cursor (which is now at end)
          document.execCommand('insertText', false, processedText)
          
          // Save the new cursor position
          saveCursorPosition()
        }
        
        // Update state
        const newHtml = editorRef.current.innerHTML
        lastValue.current = newHtml
        
        console.log('🎤 RichTextEditor: After insertion:', {
          htmlLength: newHtml.length,
          preview: newHtml.substring(0, 100),
          insertedText: processedText
        })
        
        // Notify parent of the change
        onChange(newHtml)
      },
      getValue: () => {
        const value = editorRef.current?.innerHTML || lastValue.current || '';
        console.log('🔍 getValue called, returning:', { value, length: value.length });
        return value;
      },
      getPlainText: () => {
        const text = editorRef.current?.innerText || '';
        console.log('🔍 getPlainText called, returning:', { text, length: text.length });
        return text;
      },
      setValue: (html: string) => {
        if (editorRef.current) {
          isInternalChange.current = true
          const formatted = formatText(html)
          editorRef.current.innerHTML = formatted
          lastValue.current = formatted
          onChange(formatted)
          setTimeout(() => {
            isInternalChange.current = false
          }, 100)
        }
      },
      focus: () => editorRef.current?.focus(),
      getElement: () => editorRef.current,
      saveCursor: () => saveCursorPosition()
    }), [onChange, saveCursorPosition])

    return (
      <div
        className={className}
        style={{
          border: '1px solid rgba(255, 255, 255, 0.1)',
          borderRadius: 8,
          padding: '12px',
          backgroundColor: 'rgba(255, 255, 255, 0.02)',
          ...style
        }}
      >
        <div
          ref={editorRef}
          contentEditable
          onInput={handleInput}
          onPaste={handlePaste}
          onClick={handleClick}
          onKeyUp={saveCursorPosition}
          onMouseUp={saveCursorPosition}
          onFocus={handleFocus}
          placeholder={placeholder}
          style={{
            width: '100%',
            height: '100%',
            outline: 'none',
            fontSize: 14,
            lineHeight: 1.6,
            fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif',
            color: '#e0e0e0',
            backgroundColor: 'transparent',
            whiteSpace: 'pre-wrap',
            wordBreak: 'break-word',
            overflowY: 'auto'
          }}
          data-placeholder={placeholder}
          suppressContentEditableWarning
        />
      </div>
    )
  }
)

RichTextEditor.displayName = 'RichTextEditor'

export default RichTextEditor